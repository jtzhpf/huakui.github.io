---
title: "CP-Miner: A Tool for Finding Copy-paste and Related Bugs in Operating System Code 阅读"
category: CS&Maths
#id: 57
date: 2023-12-6 09:00:00

tags: 
  - Linux
  - Staitc Analysis
  - Symbolic Execution
  - OSDI
  - OSDI'04
  - Paper
toc: true
#sticky: 1 # 数字越大置顶优先级越高。数字都需要大于 0。
#cover: /images/about.jpg # 指定封面图片的 URL
timeline: article  # 展示在时间线列表中
---

在做开题报告的时候找到了这篇论文，挺巧妙的想法，简单记录一下其思路。
<!--more-->

作者发现在现代操作系统中存在大量复制粘贴的代码，例如Linux和FreeBSD源代码的20-22%的代码存在复制粘贴的现象。但是复制粘贴后程序员会忘记修改标识符（变量、函数、类型等），由于是复制粘贴的代码，可能不存在标识符未定义或类型错误的问题，这些错误往往会通过编译时检查，成为很难检测到的隐藏错误。同时此问题由于是语义错误而非内存相关错误，也不会被静态检查器或Purify、Valgrind和CCured等动态工具检查到。

![问题示例](/CP-Miner:A_Tool_for_Finding_Copy-paste_and_Related_Bugs_in_Operating_System_Code阅读/image1.png){width=500px}

针对此问题Li等人提出了CP-Miner，该工具使用频繁序列挖掘技术通过对token流检测高效识别包括操作系统代码在内的大型软件中的复制粘贴代码，并检测复制粘贴相关的错误。


# 为什么是token流？

由于复制粘贴的代码段通常与原始代码段相似，因此复制粘贴代码的检测涉及检测相同或相似的代码段。

先前用于复制粘贴检测的技术大致可以分为三类：（1）基于字符串的方法，其中程序被分割成字符串（通常是行），然后对这些字符串进行比较，以找到重复字符串的序列；（2）基于解析树的方法，其中对代码的解析树进行模式匹配，以搜索相似的子树；（3）基于token的方法，其中程序被分割成token流，然后识别重复的token序列。

基于token的方法有其独到的优势。首先，基于字符串的方法不利用任何词法信息，因此无法处理诸如标识符重命名之类的简单修改。其次，使用解析树可能引入误报，因为具有相同语法树的两个段不一定是复制粘贴的。这是因为复制粘贴是基于代码而不是基于语法的，即它重新使用了一段代码而不是抽象语法结构。

# 频繁序列挖掘技术
在序列数据库中，当一个子序列在至少指定数量的序列中出现时（称为最小支持度 min_support），则被视为频繁子序列。这里的子序列不一定在原始序列中是连续的。我们用支持度来表示一个子序列出现的次数。包含某个给定子序列的序列被称为该子序列的支持序列。

举个🌰：

$$D=\{abced, abecf, agbch, abijc, aklc\}$$

其中，$abc$序列出现的次数为4次，$agbch$是其一个支持序列。如果最小支持度为4，那么所得到的频繁序列为$\{a:5, b:4, c:5, ab:4, ac:5, bc:4, abc:4\}$。

CP-Miner使用一种名为CloSpan（闭合顺序模式挖掘）的频繁子序列挖掘算法[^1]。

# 识别复制粘贴段的主要步骤

(1) 解析源代码：对给定的源代码进行解析，并构建一个序列数据库（序列的集合）。此外，还将有关基本块和块嵌套级别的信息传递给挖掘算法。

(2) 挖掘基本复制粘贴段：将增强型频繁子序列挖掘算法应用于序列数据库，以找到基本的复制粘贴段。

(3) 剪枝误报：使用包括标识符映射在内的各种技术来剪枝误报。

(4) 组合更大的复制粘贴段：通过组合相邻的较小段来识别更大的复制粘贴段。将组合的复制粘贴段反馈到步骤（3）以剪枝误报。这是必要的，因为组合体可能并非复制粘贴，即使每个较小段都是。

## 剪枝误报

挖掘算法或组合过程发现的复制粘贴段可能包含误报。误报的主要原因是对标识符（变量/函数/类型）进行token化，以容忍复制粘贴中的标识符重命名。由于相同类型的标识符被映射到相同的token，可能会识别出虚假的复制粘贴段。例如，所有类似于 $x = y + z$ 的语句将具有相同的哈希值，这可能导致许多误报。为了剪枝误报，CP-Miner 对基本和组合的复制粘贴段都应用了几种技术。剪枝技术包括：

### 剪枝不可映射段
此技术用于剪枝由标识符token化引入的误报。这基于这样的观察：如果程序员复制粘贴了一个代码段然后重命名了一个标识符，很可能会在新的复制粘贴段中的所有出现中重命名此标识符。因此，我们可以建立一个标识符映射，将一个段中的旧名称映射到属于同一复制粘贴组的另一个段中的相应新名称。在上图中所示的示例中，变量 `prom_phys_total` 被更改为 `prom_prom_taken`（除了第117行的错误）。

如果将一个标识符名称映射到两个或更多不同的新名称这样的冲突很少，说明映射方案是一致的。如果无法在一对复制粘贴的段之间建立一致的标识符映射，它们很可能是误报。

为了衡量冲突的数量，CP-Miner 使用一种称为 `ConflictRatio` 的度量，该度量记录了两个候选复制粘贴段之间的标识符映射的冲突比率。例如，如果段1中的变量 $A$ 被更改为段2中的 $a$ 的出现的75%，但其出现的25%被更改为其他变量，那么映射 $A
\rightarrow a$ 的 `ConflictRatio` 为25%。这两个段之间整个映射方案的 `ConflictRatio` 是每个唯一标识符的映射的 `ConflictRatio` 的加权和。给定代码段中标识符 $A$ 的权重是总标识符出现的 $A$ 的出现的比例。如果两个候选复制粘贴段的 `ConflictRatio` 高于预定义的阈值，这两个代码段将被过滤为误报。在实验中将阈值设置为60%。

### 剪枝微小段
我们的挖掘算法可能会找到仅由1-2个简单语句组成的微小复制粘贴段。如果这样的微小段无法与相邻段组合以构成更大的段，则将其从复制粘贴列表中移除。这基于这样的观察：复制粘贴的段通常不会很小，因为程序员在复制粘贴简单的小代码段时无法节省太多工作。

CP-Miner 使用token数来衡量段的大小。这个度量比语句数更合适，因为语句的长度变化很大。如果单个语句非常复杂，包含许多token，程序员仍然可以复制粘贴它。

为了剪枝微小段，CP-Miner 使用一个可调参数，称为 `min_size`。如果一对复制粘贴段中的token数少于 `min_size`，则删除这对。

### 剪枝重叠段
如果一对候选复制粘贴段彼此重叠，它们也被视为误报。CP-Miner 在一对复制粘贴段彼此重叠时停止扩展。对于一些包含许多相似段对的程序结构，比如包含许多自相似段对的 switch 语句，剪枝重叠段可以避免大多数 switch 语句中的误报。

### 剪枝间隔较大的段
除了基本复制粘贴段的挖掘过程之外，间隔约束也适用于组合的复制粘贴段。当两个相邻段组合时，新组合的大段的最大间隔可能会大于预定义的阈值 `max_total_gap`。如果是这样，组合是无效的。因此，新组合不会添加到候选集中，两个较小的段在集合中token为不可扩展。

当然，即使经过如此严格的剪枝，误报仍然可能存在。然而，作者已经手动检查了由 CP-Miner 报告的 Linux 的100个随机复制粘贴段，只发现了很少的误报（8个）。当然作者只能手动检查每个识别出的复制粘贴段，因为在软件开发过程中没有记录程序员复制粘贴操作的痕迹。

# 检测复制粘贴相关错误

正如在一开始提到的，复制粘贴相关错误的主要原因是程序员在复制粘贴后忘记始终如一地修改标识符。一旦我们获得一对复制粘贴段中的标识符之间的映射关系，我们可以找到不一致之处并报告这些复制粘贴相关的错误。
![](/CP-Miner:A_Tool_for_Finding_Copy-paste_and_Related_Bugs_in_Operating_System_Code阅读/image2.png){width=500px}

[^1]: X. Yan, J. Han, and R. Afshar. CloSpan: Mining closed sequential patterns in large datasets. In Proceedings of 2003 SIAM International Conference on Data Mining (SDM'03), San Fransisco, CA, May 2003.