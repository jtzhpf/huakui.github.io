---
title: "《Scaling symbolic evaluation for automated verification of systems code with Serval》文章精读"
category: CS&Maths
#id: 57
date: 2023-9-18 09:00:00
tags: 
  - Staitc Analysis
  - SOSP
  - 论文
toc: true
#sticky: 1 # 数字越大置顶优先级越高。数字都需要大于 0。
#cover: /images/about.jpg # 指定封面图片的 URL
timeline: article  # 展示在时间线列表中
mathjax: true
---

这篇论文介绍了一个名为Serval的框架，用于通过符号执行来对系统代码进行可扩展的自动化验证。

Serval的核心思想是将开发人员使用Rosette编写指令集解释器并转化为自动化验证器，从而实现系统软件的验证。这一框架通过符号性能分析和优化来识别和修复验证性能瓶颈。作者通过将Serval应用于现有的系统和未经验证的系统中，展示了其在找到系统错误和提高验证效率方面的有效性。
<!--more-->

## 常见验证技术
### Interactive verification
交互式验证是一种传统的验证方法，它使用交互式定理证明器来验证系统软件的正确性。这种方法的特点是需要开发人员或验证工程师的手动干预，他们使用定理证明器构建针对实现与规范之间正确性的证明。

交互式验证依赖于定理证明器，这些证明器提供了强大的逻辑工具，用于手动构建正确性证明，如使用Boyer-Moore定理证明器验证KIT内核，使用Isabelle/HOL定理证明器验证seL4微内核，CertiKOS借助于已验证的C编译器CompCert来直接推理汇编代码、利用Coq定理证明器验证整个内核等。

交互式验证可以用于验证复杂数据结构的属性和整个系统的正确性。例如，FSCQ文件系统中的树序列就是通过交互式验证实现的。这种方法可以表达复杂的性质，但需要大量工作量，人力和时间成本较高。

### Auto-active verification
自动主动验证是一种不同于交互式验证的验证方法。在这种方法中，开发人员需要在代码上添加注解，以指导验证工具进行验证。这些注解描述了代码的预期行为，例如函数的前置条件、后置条件、循环不变式等。注解的质量对于验证的成功至关重要。然后，验证工具会将带有注解的代码转化为验证条件，并调用约束求解器来检查其有效性。

相对于交互式验证，自动主动验证减轻了开发人员的证明负担。开发人员不需要手动构建复杂的证明，而是提供注解来指导验证过程，例如ExpressOS中的安全不变性验证、Verve OS中的类型安全性验证。

Ironclad这一项目的验证从应用程序代码验证到底层操作系统内核。开发人员需要编写高级规范、实现、注解，这些都用Dafny定理证明器来证明。一旦高级规范和注解准备好，验证过程将通过使用不可信的编译器将高级规范和注解转换为低级规范。低级规范是针对底层机器代码的，通常是汇编语言的形式，由 Boogie 验证器进行验证。Boogie 是一个自动验证工具，用于检查低级规范是否满足高级规范。Boogie 生成证明条件，并使用 SMT 求解器进行验证。如果验证通过，那么就意味着实现满足了高级规范中指定的性质。最后，代码在Verve上运行。

Komodo 是一个经过验证的安全监控器（security monitor），用于管理和保护软件隔离环境（enclaves）。Komodo 验证的一个重要方面是功能正确性和非干扰性属性，它确保 Komodo 完全按照其规范执行，并且不受外部干扰（如操作系统）。这是通过验证 Komodo 的实现与规范之间的一致性来实现的。Komodo 的验证使用了两种不同的工具来支持验证。规范的验证和Ironclad一样使用 Dafny。而 Komodo 的实现是使用 Vale 以ARM组件的结构化形式编写的，使Komodo能够在裸硬件上运行。

### Push-button verification
Push-button verification 将开发人员的精力集中在系统的接口设计、规范和实现上。这意味着开发人员可以更专注于构建系统的结构和功能，而不必深入研究证明。

开发者设计有限的接口，不能包含无限循环等难以验证的结构。自动验证器使用符号执行生成约束并调用约束求解器检查这些约束的有效性来实现验证。求解器的任务是确定是否存在一组输入或状态，满足系统规范和约束。如果找到满足约束的解决方案，系统被认为是通过验证的。使用这种方法验证的有Yggdrasil文件系统、Hyperkernel等。缺点在于只能验证有限的属性和系统。


