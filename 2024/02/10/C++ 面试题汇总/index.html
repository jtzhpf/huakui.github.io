<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf8"/>
    <meta name="viewport" content="initial-scale=1.0, width=device-width"/>
    <title>
      
        C/C++ 面试题 | ZPF.SITE
      
    </title>
    <meta name="description" content=""/>
    <meta name="keywords" content=""/>
    
      <link rel="apple-touch-icon"
            sizes="180x180"
            href="/images/apple-touch-icon.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="32x32"
            href="/images/favicon-32x32.png"/>
    
    
      <link rel="icon"
            type="image/png"
            sizes="16x16"
            href="/images/favicon-16x16.png"/>
    
    
      <link rel="mask-icon"
            href="/images/logo.svg"
            color=""/>
    
    
    
      
  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/regular.ttf);
        font-weight: regular;
    }
  </style>

  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/bold.ttf);
        font-weight: bold;
    }
  </style>


    
    <link rel="stylesheet"
          type="text/css"
          href='/css/layout.css'/>
    
    
  <link rel="stylesheet" type="text/css" href="/css/post.css"/>
  

  <meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>
  <body>
    <div class="head">
      <div class="nav">
        <a href='/' class="nav-logo">
          <img alt="logo" height="60px" width="60px" src="/images/logo.svg"/>
        </a>
        <input id="navBtn" type="checkbox"/>
        <div class="nav-menu">
          
            
              <a class="nav-menu-item" href="/CS&Maths">Computer Science & Maths</a>
            
              <a class="nav-menu-item" href="/Life">Life</a>
            
          
          
        </div>
        <label class="nav-btn" for="navBtn"></label>
      </div>
    </div>
    <div class="body">
      
  <article class="post-content">
    <div class="post-inner--toc">
      <div class="post-content__head">
        <div class="post-title">C/C++ 面试题</div>
        <div class="post-info">
          
  <a href="/tags/C/" class="post-tag">#C</a><a href="/tags/C/" class="post-tag">#C++</a>


          <span class="post-date">2024-02-10</span>
        </div>
      </div>
      
        <aside class="toc-outer">
          <div class="toc-title">目录</div>
          <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%8E%E8%A7%A3%E6%8C%87%E9%92%88"><span class="post-toc-text">二维数组的指针与解指针</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%8E%E4%B9%88%E6%A0%B7%E7%A6%81%E6%AD%A2%E4%BA%A7%E7%94%9F%E5%A0%86%E5%AF%B9%E8%B1%A1%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D"><span class="post-toc-text">怎么样禁止产生堆对象？(静态分配)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%8E%E4%B9%88%E6%A0%B7%E7%A6%81%E6%AD%A2%E4%BA%A7%E7%94%9F%E6%A0%88%E5%AF%B9%E8%B1%A1%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="post-toc-text">怎么样禁止产生栈对象？（动态分配）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95-1-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="post-toc-text">方法 1: 使用私有构造函数和析构函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95-2-%E4%BD%BF%E7%94%A8-protected-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="post-toc-text">方法 2: 使用 protected 构造函数和析构函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="post-toc-text">对象复用与零拷贝</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BC%A0%E5%8F%82%E9%A1%BA%E5%BA%8F"><span class="post-toc-text">传参顺序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="post-toc-text">移动构造函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F"><span class="post-toc-text">基本数据类型大小</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F"><span class="post-toc-text">结构体大小</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#pragma-pack"><span class="post-toc-text">#pragma pack</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BD%8D%E5%9F%9F"><span class="post-toc-text">位域</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="post-toc-text">静态类型、动态类型、静态绑定和动态绑定</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8Bstatic-type"><span class="post-toc-text">1. 静态类型（Static Type）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8Bdynamic-type"><span class="post-toc-text">2. 动态类型（Dynamic Type）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9Astatic-binding"><span class="post-toc-text">3. 静态绑定（Static Binding）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Adynamic-binding"><span class="post-toc-text">4. 动态绑定（Dynamic Binding）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="post-toc-text">虚函数和默认参数</span></a></li></ol>
          <a href="#" class="toc-top">回到顶部</a>
        </aside>
      
      <div class="post-content__body">
        
          <div class="post-gallery">
            
          </div>
        
        <h3 id="二维数组的指针与解指针">二维数组的指针与解指针</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> A[<span class="hljs-number">10</span>][<span class="hljs-number">20</span>]; <br>A a;<br>A* b=a;<br><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> { <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a:\t\t%d\n"</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a[0]:\t\t%d\n"</span>, a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"*a:\t\t%d\n"</span>, *a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"*a+1:\t\t%d\n"</span>, *a+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;a[0][0]:\t%d\n"</span>, &amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;a[0][1]:\t%d\n"</span>, &amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a+1:\t\t%d\n"</span>, a+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a[1]:\t\t%d\n"</span>, a[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;a[1][0]:\t%d\n"</span>, &amp;a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;a[1][1]:\t%d\n"</span>, &amp;a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;a+1:\t\t%d\n"</span>, &amp;a+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;a[0]+1:\t%d\n"</span>, &amp;a[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;a[0][0]+1:\t%d\n"</span>, &amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// printf("&amp;&amp;a[0][0]+1:\t%d\n", &amp;&amp;a[0][0]+1);  // wrong</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"b:\t\t%d\n"</span>, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"b+1:\t\t%d\n"</span>, b+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;b:\t\t%d\n"</span>, &amp;b);<br>} <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    fun(); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">a:              164651040<br>a[0]:           164651040<br>*a:             164651040<br>*a+1:           164651044<br>&amp;a[0][0]:       164651040<br>&amp;a[0][1]:       164651044<br>a+1:            164651120<br>a[1]:           164651120<br>&amp;a[1][0]:       164651120<br>&amp;a[1][1]:       164651124<br>&amp;a+1:           164651840<br>&amp;a[0]+1:        164651120<br>&amp;a[0][0]+1:     164651044<br><br>b:              164651040<br>b+1:            164651840<br>&amp;b:             164651024<br></code></pre></td></tr></table></figure>
<p>二维数组<code>a[10][20]</code>中，<code>a+1</code>、<code>a[1]</code>、<code>&amp;a[0]+1</code>表示第一层数组元素（a[0]、a[1]...）的地址，<code>*a+1</code>、<code>a[0][1]</code>、<code>&amp;a[0][0]+1</code>表示第二层数组元素（a[0][0]、a[0][1]...）的地址，<code>&amp;a</code>表示二维数组本身的地址。</p>
<p>如果将该二维数组赋值给指针<code>b</code>，则<code>b</code>表示二维数组本身的地址，<code>&amp;b</code>表示指针本身的地址。</p>
<h3 id="怎么样禁止产生堆对象静态分配">怎么样禁止产生堆对象？(静态分配)</h3>
<p>在C++中，如果你想禁止某个类生成堆对象（即只能在栈上创建该对象），你可以通过将类的 <code>operator new</code> 和 <code>operator delete</code> 重载并将它们声明为私有或删除（<code>= delete</code>）。这会阻止在堆上使用 <code>new</code> 操作符创建对象。</p>
<p>以下是一个简单的示例：</p>
<p><strong>方式 1: 重载并私有化 <code>operator new</code> 和 <code>operator delete</code></strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 公共构造函数和析构函数</span><br>    <span class="hljs-built_in">MyClass</span>() {}<br>    ~<span class="hljs-built_in">MyClass</span>() {}<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有化的 new 和 delete 操作符，禁止堆分配</span><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span>{<br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);<br>    }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>{<br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    MyClass obj;               <span class="hljs-comment">// 正确，栈上分配</span><br>    MyClass* pObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();  <span class="hljs-comment">// 错误，无法在堆上分配对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure></p>
<p>在这个示例中，<code>operator new</code> 和 <code>operator delete</code> 被声明为私有，这意味着在类的外部无法通过 <code>new</code> 操作符在堆上创建对象。由于 <code>main</code> 函数无法访问私有成员，尝试在堆上创建对象时会导致编译错误。</p>
<p><strong>方式 2: 删除 <code>operator new</code> 和 <code>operator delete</code></strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 公共构造函数和析构函数</span><br>    <span class="hljs-built_in">MyClass</span>() {}<br>    ~<span class="hljs-built_in">MyClass</span>() {}<br><br>    <span class="hljs-comment">// 禁止在堆上创建对象</span><br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span> </span>= <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> </span>= <span class="hljs-keyword">delete</span>;<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    MyClass obj;               <span class="hljs-comment">// 正确，栈上分配</span><br>    MyClass* pObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();  <span class="hljs-comment">// 错误，无法在堆上分配对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure></p>
<p>在这个示例中，我们将 <code>operator new</code> 和 <code>operator delete</code> 标记为 <code>= delete</code>，这会完全禁止在堆上创建和销毁对象。这样做的效果是，当你试图使用 <code>new</code> 操作符在堆上分配对象时，编译器会直接给出错误提示。</p>
<p>通过这些方法，你可以确保某个类只能在栈上创建，而无法在堆上分配。</p>
<h3 id="怎么样禁止产生栈对象动态分配">怎么样禁止产生栈对象？（动态分配）</h3>
<p>在 C++ 中，可以通过将类的构造函数或析构函数声明为 <code>private</code> 或 <code>protected</code> 来禁止从栈上创建该类的对象。这样，外部代码无法直接在栈上声明类的对象，但可以通过允许堆上分配对象来控制对象的生命周期。</p>
<h4 id="方法-1-使用私有构造函数和析构函数">方法 1: 使用私有构造函数和析构函数</h4>
<p>通过将类的构造函数和析构函数声明为 <code>private</code> 或 <code>protected</code>，可以防止在栈上创建对象。用户可以通过静态工厂方法或动态内存分配（使用 <code>new</code>）来创建对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">MyClass</span>() { std::cout &lt;&lt; <span class="hljs-string">"Object created\n"</span>; }  <span class="hljs-comment">// 私有构造函数</span><br>    ~<span class="hljs-built_in">MyClass</span>() { std::cout &lt;&lt; <span class="hljs-string">"Object destroyed\n"</span>; }  <span class="hljs-comment">// 私有析构函数</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 静态工厂方法，通过堆上分配对象</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> MyClass* <span class="hljs-title">createObject</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();<br>    }<br><br>    <span class="hljs-comment">// 提供一个删除对象的接口</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">destroyObject</span><span class="hljs-params">(MyClass* obj)</span> </span>{<br>        <span class="hljs-keyword">delete</span> obj;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<br>        std::cout &lt;&lt; <span class="hljs-string">"Display method called\n"</span>;<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// MyClass obj;  // 错误！构造函数是私有的，不能在栈上创建对象</span><br><br>    <span class="hljs-comment">// 只能通过堆上分配</span><br>    MyClass* obj = MyClass::<span class="hljs-built_in">createObject</span>();<br>    obj-&gt;<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-comment">// 销毁对象</span><br>    MyClass::<span class="hljs-built_in">destroyObject</span>(obj);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>
<h4 id="方法-2-使用-protected-构造函数和析构函数">方法 2: 使用 <code>protected</code> 构造函数和析构函数</h4>
<p>使用 <code>protected</code> 而不是 <code>private</code> 可以让类的派生类（子类）继承并创建对象，但仍然阻止从栈上直接创建基类对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseClass</span> {<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">BaseClass</span>() { std::cout &lt;&lt; <span class="hljs-string">"BaseClass created\n"</span>; }  <span class="hljs-comment">// 受保护的构造函数</span><br>    ~<span class="hljs-built_in">BaseClass</span>() { std::cout &lt;&lt; <span class="hljs-string">"BaseClass destroyed\n"</span>; }  <span class="hljs-comment">// 受保护的析构函数</span><br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedClass</span> : <span class="hljs-keyword">public</span> BaseClass {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DerivedClass</span>() {<br>        std::cout &lt;&lt; <span class="hljs-string">"DerivedClass created\n"</span>;<br>    }<br>    ~<span class="hljs-built_in">DerivedClass</span>() {<br>        std::cout &lt;&lt; <span class="hljs-string">"DerivedClass destroyed\n"</span>;<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// BaseClass base;  // 错误！受保护的构造函数禁止栈上创建</span><br><br>    DerivedClass derived;  <span class="hljs-comment">// 允许栈上创建派生类对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>
<h3 id="对象复用与零拷贝">对象复用与零拷贝</h3>
<p><img src="/C/C++%20面试题/image1.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span><br>{<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//初始构造函数</span><br>    <span class="hljs-built_in">Person</span>(string p_name, <span class="hljs-type">int</span> p_age): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(p_name)), <span class="hljs-built_in">age</span>(p_age)<br>    {<br>         cout &lt;&lt; <span class="hljs-string">"\tI have been constructed"</span> &lt;&lt;endl;<br>    }<br>     <span class="hljs-comment">//拷贝构造函数</span><br>     <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; other): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(other.name)), <span class="hljs-built_in">age</span>(other.age)<br>    {<br>         cout &lt;&lt; <span class="hljs-string">"\tI have been copy constructed"</span> &lt;&lt;endl;<br>    }<br>     <span class="hljs-comment">//转移构造函数</span><br>     <span class="hljs-built_in">Person</span>(Person&amp;&amp; other): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(other.name)), <span class="hljs-built_in">age</span>(other.age)<br>    {<br>         cout &lt;&lt; <span class="hljs-string">"\tI have been moved"</span>&lt;&lt;endl;<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    vector&lt;Person&gt; people;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">30</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 使用 push_back 插入对象</span><br>    cout&lt;&lt;<span class="hljs-string">"1.push_back:"</span>&lt;&lt;endl;<br>    people.<span class="hljs-built_in">push_back</span>(p1); <span class="hljs-comment">// 调用拷贝构造函数</span><br><br>    <span class="hljs-comment">// 使用 push_back 插入对象</span><br>    cout&lt;&lt;<span class="hljs-string">"2.push_back:"</span>&lt;&lt;endl;<br>    people.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">25</span>)); <span class="hljs-comment">// 调用移动构造函数，因为临时对象被传递</span><br>    <br>    <span class="hljs-comment">// 使用 emplace_back 直接原地构造对象</span><br>    cout&lt;&lt;<span class="hljs-string">"3.emplace_back:"</span>&lt;&lt;endl;<br>    people.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 直接构造，无需拷贝或移动</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//预期结果：</span><br><span class="hljs-comment">//        I have been constructed  // 构造 p1</span><br><span class="hljs-comment">//1. push_back:</span><br><span class="hljs-comment">//        I have been copy constructed  // 复制 p1</span><br><span class="hljs-comment">//2. push_back:</span><br><span class="hljs-comment">//        I have been constructed  // 构造临时对象 "Bob"</span><br><span class="hljs-comment">//        I have been moved        // 移动临时对象 "Bob"</span><br><span class="hljs-comment">//3. emplace_back:</span><br><span class="hljs-comment">//        I have been constructed  // 直接构造 "Charlie"</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//        I have been constructed</span><br><span class="hljs-comment">//1.push_back:</span><br><span class="hljs-comment">//        I have been copy constructed</span><br><span class="hljs-comment">//2.push_back:</span><br><span class="hljs-comment">//        I have been constructed</span><br><span class="hljs-comment">//        I have been moved</span><br><span class="hljs-comment">//        I have been copy constructed</span><br><span class="hljs-comment">//3.emplace_back:</span><br><span class="hljs-comment">//        I have been constructed</span><br><span class="hljs-comment">//        I have been copy constructed</span><br><span class="hljs-comment">//        I have been copy constructed</span><br></code></pre></td></tr></table></figure>
<p>嗯？怎么和说的不一样？最后<strong>emplace_back</strong>怎么调用了2次拷贝构造函数？ 这次让我们换一下顺序。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    vector&lt;Person&gt; people;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">30</span>)</span></span>;<br>        <br>    <span class="hljs-comment">// 使用 emplace_back 直接原地构造对象</span><br>    cout&lt;&lt;<span class="hljs-string">"3.emplace_back:"</span>&lt;&lt;endl;<br>    people.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 直接构造，无需拷贝或移动</span><br>    <br>    <span class="hljs-comment">// 使用 push_back 插入对象</span><br>    cout&lt;&lt;<span class="hljs-string">"1.push_back:"</span>&lt;&lt;endl;<br>    people.<span class="hljs-built_in">push_back</span>(p1); <span class="hljs-comment">// 调用拷贝构造函数</span><br>    <br>    <span class="hljs-comment">// 使用 push_back 插入对象</span><br>    cout&lt;&lt;<span class="hljs-string">"2.push_back:"</span>&lt;&lt;endl;<br>    people.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">25</span>)); <span class="hljs-comment">// 调用移动构造函数，因为临时对象被传递</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//        I have been constructed</span><br><span class="hljs-comment">//3.emplace_back:</span><br><span class="hljs-comment">//        I have been constructed</span><br><span class="hljs-comment">//1.push_back:</span><br><span class="hljs-comment">//        I have been copy constructed</span><br><span class="hljs-comment">//        I have been copy constructed</span><br><span class="hljs-comment">//2.push_back:</span><br><span class="hljs-comment">//        I have been constructed</span><br><span class="hljs-comment">//        I have been moved</span><br><span class="hljs-comment">//        I have been copy constructed</span><br><span class="hljs-comment">//        I have been copy constructed</span><br></code></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    vector&lt;Person&gt; people;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">30</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 使用 push_back 插入对象</span><br>    cout&lt;&lt;<span class="hljs-string">"2.push_back:"</span>&lt;&lt;endl;<br>    people.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">25</span>)); <span class="hljs-comment">// 调用移动构造函数，因为临时对象被传递</span><br>    <br>    <span class="hljs-comment">// 使用 emplace_back 直接原地构造对象</span><br>    cout&lt;&lt;<span class="hljs-string">"3.emplace_back:"</span>&lt;&lt;endl;<br>    people.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 直接构造，无需拷贝或移动</span><br>    <br>    <span class="hljs-comment">// 使用 push_back 插入对象</span><br>    cout&lt;&lt;<span class="hljs-string">"1.push_back:"</span>&lt;&lt;endl;<br>    people.<span class="hljs-built_in">push_back</span>(p1); <span class="hljs-comment">// 调用拷贝构造函数</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//        I have been constructed</span><br><span class="hljs-comment">//2.push_back:</span><br><span class="hljs-comment">//        I have been constructed</span><br><span class="hljs-comment">//        I have been moved</span><br><span class="hljs-comment">//3.emplace_back:</span><br><span class="hljs-comment">//        I have been constructed</span><br><span class="hljs-comment">//        I have been copy constructed</span><br><span class="hljs-comment">//1.push_back:</span><br><span class="hljs-comment">//        I have been copy constructed</span><br><span class="hljs-comment">//        I have been copy constructed</span><br><span class="hljs-comment">//        I have been copy constructed</span><br></code></pre></td></tr></table></figure>
<p>我们可以发现<strong>emplace_back确实没有调用拷贝/移动构造函数，只需使用普通构造函数</strong>。那么上面这个问题是为什么？</p>
<p>输出和预期不符，主要原因在于 <code>std::vector</code> 的动态扩容行为。具体来说，当 <code>std::vector</code> 需要扩展其内部存储空间时，它会重新分配更大的存储空间，并将已有的元素拷贝或移动到新的存储空间中。因此，发生了多次拷贝构造或移动构造，而这些额外的操作就是导致输出和预期不同的原因。</p>
<p><code>std::vector</code> 在插入元素时会动态调整其容量（<code>capacity</code>）。当 <code>size</code> 超过当前的 <code>capacity</code> <code>时，vector</code> 会重新分配更大的内存，并将旧的元素拷贝到新的位置。这就是为什么你看到多次调用拷贝构造函数的原因，尤其是在 <code>emplace_back</code> 和 <code>push_back</code> 操作之间。</p>
<p>默认情况下，<code>vector</code> 的扩展通常是按一定倍数增加容量，比如 2 倍。当 <code>vector</code> 需要重新分配存储空间时，会调用拷贝构造函数或移动构造函数来将现有元素复制或移动到新的内存中。</p>
<p>如果你想避免额外的拷贝或移动构造操作，可以在开始时手动预留足够的空间，使用 <code>vector::reserve</code> 函数。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    vector&lt;Person&gt; people;<br>    people.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 预留3个元素的空间，避免扩容</span><br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">30</span>)</span></span>;<br><br>    <span class="hljs-comment">// 使用 push_back 插入对象</span><br>    cout &lt;&lt; <span class="hljs-string">"1.push_back:"</span> &lt;&lt; endl;<br>    people.<span class="hljs-built_in">push_back</span>(p1); <span class="hljs-comment">// 调用拷贝构造函数</span><br><br>    <span class="hljs-comment">// 使用 push_back 插入对象</span><br>    cout &lt;&lt; <span class="hljs-string">"2.push_back:"</span> &lt;&lt; endl;<br>    people.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">"Bob"</span>, <span class="hljs-number">25</span>)); <span class="hljs-comment">// 调用移动构造函数</span><br><br>    <span class="hljs-comment">// 使用 emplace_back 直接原地构造对象</span><br>    cout &lt;&lt; <span class="hljs-string">"3.emplace_back:"</span> &lt;&lt; endl;<br>    people.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 直接构造，无需拷贝或移动</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//        I have been constructed</span><br><span class="hljs-comment">//1.push_back:</span><br><span class="hljs-comment">//        I have been copy constructed</span><br><span class="hljs-comment">//2.push_back:</span><br><span class="hljs-comment">//        I have been constructed</span><br><span class="hljs-comment">//        I have been moved</span><br><span class="hljs-comment">//3.emplace_back:</span><br><span class="hljs-comment">//        I have been constructed</span><br></code></pre></td></tr></table></figure></p>
<h3 id="传参顺序">传参顺序</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function"></span>{<br>	cout &lt;&lt; <span class="hljs-string">"f():"</span>&lt;&lt;n &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> n;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> param1, <span class="hljs-type">int</span> param2)</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-type">int</span> var1 = param1;<br>	<span class="hljs-type">int</span> var2 = param2;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">"var1=%d,var2=%d\n"</span>, <span class="hljs-built_in">f</span>(var1), <span class="hljs-built_in">f</span>(var2));<span class="hljs-comment">//如果将printf换为cout进行输出，输出结果则刚好相反</span><br>	cout &lt;&lt;<span class="hljs-string">"var1="</span>&lt;&lt; <span class="hljs-built_in">f</span>(var1)&lt;&lt;<span class="hljs-string">",var2="</span>&lt;&lt; <span class="hljs-built_in">f</span>(var2) &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-comment">//f():2</span><br><span class="hljs-comment">//f():1</span><br><span class="hljs-comment">//var1=1,var2=2</span><br><span class="hljs-comment">//var1=f():1</span><br><span class="hljs-comment">//1,var2=f():2</span><br><span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure>
<h3 id="移动构造函数">移动构造函数</h3>
<p>移动构造函数在 C++ 中用于实现对象的“移动语义”，这使得资源（如内存或文件句柄）从一个对象转移到另一个对象，而无需复制。移动构造函数通过使用 <code>std::move</code> 来获取一个右值引用，从而避免不必要的资源复制操作，提高程序的性能。</p>
<p>下面是一个简单的例子，展示了如何实现和使用移动构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span>  <span class="hljs-comment">// for std::move</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyVector</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>* data;     <span class="hljs-comment">// 指向动态分配的数组</span><br>    <span class="hljs-type">size_t</span> size;   <span class="hljs-comment">// 数组大小</span><br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MyVector</span>(<span class="hljs-type">size_t</span> s) : <span class="hljs-built_in">size</span>(s), <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[s]) {<br>        std::cout &lt;&lt; <span class="hljs-string">"Constructing MyVector of size "</span> &lt;&lt; size &lt;&lt; std::endl;<br>    }<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">MyVector</span>(<span class="hljs-type">const</span> MyVector&amp; other) : <span class="hljs-built_in">size</span>(other.size), <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[other.size]) {<br>        std::cout &lt;&lt; <span class="hljs-string">"Copy constructor called"</span> &lt;&lt; std::endl;<br>        std::<span class="hljs-built_in">copy</span>(other.data, other.data + other.size, data);<br>    }<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">MyVector</span>(MyVector&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">size</span>(other.size), <span class="hljs-built_in">data</span>(other.data) {<br>        std::cout &lt;&lt; <span class="hljs-string">"Move constructor called"</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 移动后，将原对象的指针和大小置空</span><br>        other.data = <span class="hljs-literal">nullptr</span>;<br>        other.size = <span class="hljs-number">0</span>;         <span class="hljs-comment">// 必须的，如果没有会出现double free的问题</span><br>    }<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyVector</span>() {<br>        std::cout &lt;&lt; <span class="hljs-string">"Destructor called"</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">delete</span>[] data;<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 创建一个对象</span><br>    <span class="hljs-function">MyVector <span class="hljs-title">vec1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 调用构造函数</span><br><br>    <span class="hljs-comment">// 使用 std::move 将 vec1 移动到 vec2</span><br>    <span class="hljs-function">MyVector <span class="hljs-title">vec2</span><span class="hljs-params">(std::move(vec1))</span></span>; <span class="hljs-comment">// 调用移动构造函数</span><br><br>    <span class="hljs-comment">// vec1 已被移动，不能再访问其资源</span><br>    std::cout &lt;&lt; <span class="hljs-string">"vec1's size after move: "</span> &lt;&lt; vec1.size &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"vec1's data after move: "</span> &lt;&lt; vec1.data &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>
<p><strong>代码解释：</strong></p>
<ul>
<li><ol type="1">
<li><strong>构造函数</strong>：创建一个指定大小的动态数组，并初始化 <code>size</code> 和 <code>data</code>。</li>
</ol></li>
<li><ol start="2" type="1">
<li><strong>拷贝构造函数</strong>：深拷贝另一个对象的 <code>data</code>，创建新的内存块以避免资源共享。</li>
</ol></li>
<li><ol start="3" type="1">
<li><strong>移动构造函数</strong>：</li>
</ol>
<ul>
<li>使用右值引用 <code>MyVector&amp;&amp;</code> 接收一个即将销毁的对象 <code>other</code>。</li>
<li>将 <code>other</code> 的资源（<code>data</code> 和 <code>size</code>）转移给当前对象。</li>
<li>将 <code>other</code> 的指针设为 <code>nullptr</code>，并将 <code>size</code> 设为 0，防止 <code>other</code> 在销毁时释放已转移的资源。</li>
</ul></li>
<li><ol start="4" type="1">
<li><strong>析构函数</strong>：在对象销毁时释放动态分配的内存。</li>
</ol></li>
<li><ol start="5" type="1">
<li><strong><code>std::move</code></strong>：将 <code>vec1</code> 转换为右值，以便调用移动构造函数，而不是拷贝构造函数。</li>
</ol></li>
</ul>
<p><strong>输出结果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">Constructing MyVector of size 5<br>Move constructor called<br>vec1's size after move: 0<br>vec1's data after move: 0<br>Destructor called<br>Destructor called<br></code></pre></td></tr></table></figure>
<ul>
<li>创建 <code>vec1</code> 时，调用了构造函数，分配了大小为 5 的数组。</li>
<li>通过 <code>std::move</code>，<code>vec1</code> 的资源（内存）被转移到了 <code>vec2</code>，因此调用了移动构造函数。</li>
<li>移动后，<code>vec1</code> 的 <code>size</code> 变为 0，<code>data</code> 变为 <code>nullptr</code>，确保移动语义的正确性。</li>
<li>在程序结束时，分别调用 <code>vec1</code> 和 <code>vec2</code> 的析构函数，清理资源。</li>
</ul>
<h3 id="基本数据类型大小">基本数据类型大小</h3>
<p>以下是常见基本数据类型在 32 位和 64 位系统上的大小对比：</p>
<table>
<thead>
<tr class="header">
<th>数据类型</th>
<th>32 位系统大小 (bytes)</th>
<th>64 位系统大小 (bytes)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>char</code></td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td><code>short</code></td>
<td>2</td>
<td>2</td>
</tr>
<tr class="odd">
<td><code>int</code></td>
<td>4</td>
<td>4</td>
</tr>
<tr class="even">
<td><code>long</code></td>
<td>4</td>
<td>8</td>
</tr>
<tr class="odd">
<td><code>long long</code></td>
<td>8</td>
<td>8</td>
</tr>
<tr class="even">
<td><code>float</code></td>
<td>4</td>
<td>4</td>
</tr>
<tr class="odd">
<td><code>double</code></td>
<td>8</td>
<td>8</td>
</tr>
<tr class="even">
<td><code>long double</code></td>
<td>12 (或 16)</td>
<td>16</td>
</tr>
<tr class="odd">
<td><code>pointer</code></td>
<td>4</td>
<td>8</td>
</tr>
</tbody>
</table>
<h3 id="结构体大小">结构体大小</h3>
<p>一、结构体对齐规则首先要看有没有用<code>#pragma pack</code>宏声明，这个宏可以改变对齐规则，有宏定义的情况下<strong>结构体的自身宽度就是按照这个宏声明的和实际数据类型中最大值较小的那个</strong>来决定，所有内存都按照这个宽度去布局，<code>#pragma pack</code> 参数只能是 '1', '2', '4', '8', or '16'。</p>
<p>二、在没有<code>#pragma pack</code>这个宏的声明下，遵循下面三个原则：</p>
<ol type="1">
<li>第一个成员的首地址为0；</li>
<li>每个成员的首地址是自身大小的整数倍；</li>
<li>结构体的总大小，为其成员中所含<strong>最大类型的整数倍</strong>。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	cout &lt;&lt; <span class="hljs-string">"char: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) &lt;&lt; endl;       <span class="hljs-comment">// char: 1</span><br>	cout &lt;&lt; <span class="hljs-string">"short: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">short</span>) &lt;&lt; endl;     <span class="hljs-comment">// short: 2</span><br>	cout &lt;&lt; <span class="hljs-string">"int: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; endl;         <span class="hljs-comment">// int: 4</span><br>	cout &lt;&lt; <span class="hljs-string">"long: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>) &lt;&lt; endl;       <span class="hljs-comment">// long: 8</span><br>	cout &lt;&lt; <span class="hljs-string">"long long: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) &lt;&lt; endl; <span class="hljs-comment">// long long: 8</span><br>	cout &lt;&lt; <span class="hljs-string">"float: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) &lt;&lt; endl;         <span class="hljs-comment">// float: 4</span><br>	cout &lt;&lt; <span class="hljs-string">"double: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>) &lt;&lt; endl;       <span class="hljs-comment">// double: 8</span><br>	cout &lt;&lt; <span class="hljs-string">"long double: "</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">double</span>) &lt;&lt; endl; <span class="hljs-comment">// long double: 16</span><br><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span><br>	{<br>		<span class="hljs-type">int</span> x;      <span class="hljs-comment">// 0(4)</span><br>		<span class="hljs-type">char</span> y;     <span class="hljs-comment">// 4(1+3)</span><br>		<span class="hljs-type">int</span> z;      <span class="hljs-comment">// 8(4+4)</span><br>		<span class="hljs-type">double</span> a;   <span class="hljs-comment">// 16(8)</span><br>	};              <span class="hljs-comment">// 24(以double 8B对齐)</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S1, x) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S1, y) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S1, z) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S1, a) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(S1) &lt;&lt; endl;<br><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S2</span><br>	{<br>		<span class="hljs-type">int</span> x;      <span class="hljs-comment">// 0(4)</span><br>		<span class="hljs-type">char</span> y;     <span class="hljs-comment">// 4(1+1)</span><br>		<span class="hljs-type">short</span> b;    <span class="hljs-comment">// 6(2)</span><br>		<span class="hljs-type">int</span> z;      <span class="hljs-comment">// 8(4+4)</span><br>		<span class="hljs-type">double</span> a;   <span class="hljs-comment">// 16(8)</span><br>	};              <span class="hljs-comment">// 24(以double 8B对齐)</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S2, x) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S2, y) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S2, b) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S2, z) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S2, a) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(S2) &lt;&lt; endl;<br><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S3</span><br>	{<br>		<span class="hljs-type">char</span> a;     <span class="hljs-comment">// 0(1)</span><br>		<span class="hljs-type">char</span> b;     <span class="hljs-comment">// 1(1)</span><br>		<span class="hljs-type">char</span> c;     <span class="hljs-comment">// 2(1)</span><br>	};              <span class="hljs-comment">// 3(char 1B对齐)</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S3, a) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S3, b) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S3, c) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(S3) &lt;&lt; endl;<br><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S4</span><br>	{<br>		<span class="hljs-type">char</span> a;     <span class="hljs-comment">// 0(1+1)</span><br>		<span class="hljs-type">short</span> b;    <span class="hljs-comment">// 2(2)</span><br>		<span class="hljs-type">char</span> c;     <span class="hljs-comment">// 4(1+1)</span><br>	};              <span class="hljs-comment">// 6(short 2B对齐)</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S4, a) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S4, b) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S4, c) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(S4) &lt;&lt; endl;<br><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S5</span><br>	{<br>		<span class="hljs-type">char</span> a;     <span class="hljs-comment">// 0(1+3)</span><br>		<span class="hljs-type">int</span>  b;     <span class="hljs-comment">// 4(4)</span><br>		<span class="hljs-type">short</span> c;    <span class="hljs-comment">// 8(2+2)</span><br>	};              <span class="hljs-comment">// 12(short 2B对齐)</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S5, a) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S5, b) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S5, c) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(S5) &lt;&lt; endl;<br><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S6</span><br>	{<br>		<span class="hljs-type">char</span> d[<span class="hljs-number">7</span>];  <span class="hljs-comment">// 0(7+1)</span><br>		<span class="hljs-type">float</span> a;    <span class="hljs-comment">// 8(4)</span><br>		<span class="hljs-type">short</span>  b;   <span class="hljs-comment">// 12(2+2)</span><br>		<span class="hljs-type">char</span>* c;    <span class="hljs-comment">// 16(8)</span><br>	};              <span class="hljs-comment">// 24(float 4B对齐)</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S6, d) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S6, a) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S6, b) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S6, c) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(S6) &lt;&lt; endl;<br><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S7</span><br>	{<br>		<span class="hljs-type">char</span> d[<span class="hljs-number">7</span>];  <span class="hljs-comment">// 0(7+1)</span><br>		<span class="hljs-type">double</span> a;   <span class="hljs-comment">// 8(8)</span><br>		<span class="hljs-type">short</span>  b;   <span class="hljs-comment">// 16(2+6)</span><br>		<span class="hljs-type">char</span>* c;    <span class="hljs-comment">// 24(8)</span><br>		<span class="hljs-type">char</span> e;     <span class="hljs-comment">// 32(1+1)</span><br>		<span class="hljs-type">short</span> f;    <span class="hljs-comment">// 34(2+4)</span><br>	};              <span class="hljs-comment">// 40(double 8B对齐)</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S7, d) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S7, a) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S7, b) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S7, c) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S7, e) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S7, f) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(S7) &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>
<h4 id="pragma-pack">#pragma pack</h4>
<p>加了 <code>#pragma pack</code> 会怎样？ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span>  pack(1)</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span><br>	{<br>		<span class="hljs-type">int</span> x;      <span class="hljs-comment">// 0(4)</span><br>		<span class="hljs-type">char</span> y;     <span class="hljs-comment">// 4(1)</span><br>		<span class="hljs-type">int</span> z;      <span class="hljs-comment">// 5(4)</span><br>		<span class="hljs-type">double</span> a;   <span class="hljs-comment">// 9(8)</span><br>	};              <span class="hljs-comment">// 17</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S1, x) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S1, y) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S1, z) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S1, a) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(S1) &lt;&lt; endl;<br>	<br>	<span class="hljs-meta">#<span class="hljs-keyword">pragma</span>  pack(2)</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S2</span><br>	{<br>		<span class="hljs-type">int</span> x;      <span class="hljs-comment">// 0(4)</span><br>		<span class="hljs-type">char</span> y;     <span class="hljs-comment">// 4(1+1)</span><br>		<span class="hljs-type">int</span> z;      <span class="hljs-comment">// 6(4)</span><br>		<span class="hljs-type">double</span> a;   <span class="hljs-comment">// 10(8)</span><br>	};              <span class="hljs-comment">// 18</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S2, x) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S2, y) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S2, z) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S2, a) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(S2) &lt;&lt; endl;<br>	<br>	<span class="hljs-meta">#<span class="hljs-keyword">pragma</span>  pack(16)</span><br>	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S3</span><br>	{<br>		<span class="hljs-type">int</span> x;      <span class="hljs-comment">// 0</span><br>		<span class="hljs-type">char</span> y;     <span class="hljs-comment">// 4</span><br>		<span class="hljs-type">int</span> z;      <span class="hljs-comment">// 8</span><br>		<span class="hljs-type">double</span> a;   <span class="hljs-comment">// 16</span><br>	};              <span class="hljs-comment">// 24</span><br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S3, x) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S3, y) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S3, z) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S3, a) &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(S3) &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure> <strong><code>#pragma pack</code> 对齐规则总结:</strong></p>
<ol type="1">
<li><strong>默认对齐（没有 <code>#pragma pack</code>）</strong>：
<ul>
<li>默认情况下，编译器按照结构体成员类型的大小（也叫“自然对齐”）进行对齐。每个成员在结构体中的地址必须是该成员大小的倍数。</li>
<li>编译器会插入填充字节以确保每个成员在正确的对齐边界上。</li>
</ul></li>
<li><strong><code>#pragma pack(n)</code> 指定对齐</strong>：
<ul>
<li>使用 <code>#pragma pack(n)</code>，可以显式指定一个对齐大小 <code>n</code>，告诉编译器所有成员按照 <code>n</code> 字节对齐。</li>
<li>当成员的自然对齐要求大于 <code>n</code> 时，成员会按 <code>n</code> 字节对齐（即强制对齐），如果自然对齐小于或等于 <code>n</code>，则按成员的自然对齐进行对齐。</li>
</ul></li>
<li><strong>对齐的行为</strong>：
<ul>
<li><strong>成员对齐</strong>：<code>#pragma pack(n)</code> 会限制结构体中每个成员的对齐方式，所有成员的起始地址都要对齐到 <code>n</code> 或该成员类型的自然对齐值，取较小者。例如，如果 <code>n</code> 为 2，<code>int</code> 类型的成员将按 2 字节对齐（虽然它通常按 4 字节对齐）。</li>
<li><strong>结构体大小对齐</strong>：结构体的总大小通常也会对齐到 <code>n</code> 字节或最大成员的自然对齐值的倍数。</li>
</ul></li>
</ol>
<h4 id="位域">位域</h4>
<p>除此之外，还有一种特殊情况，叫<strong>位域</strong>： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span><br>{<br>       <span class="hljs-type">char</span> a : <span class="hljs-number">7</span>;   <span class="hljs-comment">// 7 bits</span><br>       <span class="hljs-type">int</span> b : <span class="hljs-number">11</span>;   <span class="hljs-comment">// 11 bits</span><br>       <span class="hljs-type">int</span> c : <span class="hljs-number">4</span>;    <span class="hljs-comment">// 4 bits</span><br>       <span class="hljs-type">int</span> d : <span class="hljs-number">10</span>;   <span class="hljs-comment">// 10 bits</span><br>       <span class="hljs-type">char</span> index;   <span class="hljs-comment">// 1 byte (8 bits)</span><br>};                <span class="hljs-comment">// 8 byte</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S1, a) &lt;&lt; endl;    <span class="hljs-comment">// offsetof 在位域情况下编译报错！</span><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(S1) &lt;&lt; endl;<br></code></pre></td></tr></table></figure> 在这个 <code>struct test</code> 中，使用了 <strong>位域（bit field）</strong> 来定义结构体成员。位域允许你定义精确的位数来存储某个成员。理解位域的对齐和存储方式稍微复杂一些，因为它涉及到位的排列和字节对齐。让我们逐一分析每个成员的存储方式和对齐情况。</p>
<p><strong>位域的存储规则：</strong> - 位域的存储依赖于具体的编译器实现，但通常来说，位域会按照其底层类型的大小进行分配和存储。例如，<code>int</code> 通常占 4 字节（32 位），位域会在这个范围内尽可能地放置多个字段。 - 如果一个字段不能放入当前的剩余位域空间中，那么它会被存储在新的机器字中，新的机器字会遵守该字段类型的对齐规则。</p>
<p><strong>逐个字段分析：</strong></p>
<ol type="1">
<li><strong><code>char a : 7</code></strong>：
<ul>
<li><code>char a</code> 占用 7 位，但由于 <code>char</code> 是 1 字节（8 位），剩下的 1 位可能留作填充位或用于存储后续位域。</li>
<li>假设编译器允许多个位域共享同一个字节，因此 <code>a</code> 占据结构体的前 7 位。</li>
</ul></li>
<li><strong><code>int b : 11</code></strong>：
<ul>
<li><code>int b</code> 需要 11 位。由于 <code>char a : 7</code> 已占用了 1 字节中的 7 位，<code>b</code> 的前 1 位将填充剩下的第一个字节，后续的 10 位将跨越到下一个 32 位的 <code>int</code> 单元。</li>
<li>也就是说，<code>b</code> 的前 1 位放在第一个字节的最后一位，剩余的 10 位占用第二个字节的前 10 位。</li>
</ul></li>
<li><strong><code>int c : 4</code></strong>：
<ul>
<li><code>c</code> 需要 4 位。剩下的 <code>b</code> 已经占用了 11 位，因此 <code>c</code> 可以紧接着在剩余的 <code>b</code> 后面的位上使用。这意味着 <code>c</code> 将占据剩余的 4 位，而不需要新开辟一个新的机器字。</li>
</ul></li>
<li><strong><code>int d : 10</code></strong>：
<ul>
<li><code>d</code> 需要 10 位。由于前面已经使用了 <code>11 + 4 = 15</code> 位，剩下的空间不足以存储 <code>d</code>。因此，<code>d</code> 将被存储在新的 <code>int</code> 单元中，跨越两个字节。</li>
</ul></li>
<li><strong><code>char index</code></strong>：
<ul>
<li><code>index</code> 是一个完整的 <code>char</code>，占用 1 字节的存储空间，按 1 字节对齐。</li>
</ul></li>
</ol>
<p><strong>总体布局和对齐：</strong></p>
<ul>
<li>位域成员 <code>a</code>, <code>b</code>, <code>c</code>, 和 <code>d</code> 将按照上面分析的位来分配，总共使用了 7 + 11 + 4 + 10 = 32 位（4 字节）来存储这些成员。</li>
<li>位域成员会被打包在一起，不会跨越超过其类型所能表示的范围。例如，<code>int</code> 位域成员不会跨越 32 位的机器字边界。</li>
<li>由于 <code>index</code> 是一个常规的 <code>char</code> 成员，它将按照 1 字节对齐，存储在新的字节空间中。</li>
</ul>
<p><strong>计算大小：</strong></p>
<p>假设 <code>int</code> 是 4 字节，<code>char</code> 是 1 字节，并且结构体的对齐按 4 字节来进行：</p>
<ol type="1">
<li><strong>位域部分</strong>：<code>a + b + c + d</code> 总共占 32 位，正好等于 4 字节（1 个 <code>int</code> 的大小）。</li>
<li><strong><code>index</code> 成员</strong>：<code>char index</code> 占用 1 字节。</li>
</ol>
<p>因此，结构体的总大小为： - 4 字节（位域部分） - 1 字节（<code>char index</code>） - 再加上对齐需要的 3 个填充字节（成员int为4字节，为了让整个结构体的大小符合 4 字节对齐规则）。</p>
<p>最终结构体的总大小为 8 字节。</p>
<h3 id="静态类型动态类型静态绑定和动态绑定">静态类型、动态类型、静态绑定和动态绑定</h3>
<p>在 C++ 中，静态类型、动态类型、静态绑定和动态绑定是重要的概念，用于理解如何解析函数调用和类型信息。以下是这几个概念的解释和示例：</p>
<h4 id="静态类型static-type">1. 静态类型（Static Type）</h4>
<p><strong>静态类型</strong>是编译时确定的类型。它是指在编译过程中变量的声明类型。编译器根据静态类型来检查代码的正确性。</p>
<p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"Base show\n"</span>; }<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"Derived show\n"</span>; }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    Base* basePtr; <span class="hljs-comment">// 静态类型是 Base*</span><br>    Derived derivedObj;<br>    basePtr = &amp;derivedObj; <span class="hljs-comment">// 静态类型为 Base*，动态类型为 Derived</span><br>}<br></code></pre></td></tr></table></figure> 在这个示例中，<code>basePtr</code> 的静态类型是 <code>Base*</code>，它在编译时确定。</p>
<h4 id="动态类型dynamic-type">2. 动态类型（Dynamic Type）</h4>
<p><strong>动态类型</strong>是在运行时确定的类型。它是对象的实际类型，而不是指向对象的指针或引用的类型。</p>
<p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    Base* basePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>(); <span class="hljs-comment">// 静态类型是 Base*，动态类型是 Derived</span><br>    basePtr-&gt;<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 调用的是 Derived::show，因为实际对象是 Derived</span><br>    <span class="hljs-keyword">delete</span> basePtr;<br>}<br></code></pre></td></tr></table></figure> 在这个示例中，虽然 <code>basePtr</code> 的静态类型是 <code>Base*</code>，但动态类型是 <code>Derived</code>。因此，<code>basePtr-&gt;show()</code> 调用的是 <code>Derived</code> 类中的 <code>show</code> 函数。</p>
<h4 id="静态绑定static-binding">3. 静态绑定（Static Binding）</h4>
<p><strong>静态绑定</strong>（或称为早期绑定）是编译时确定函数的调用。函数调用的具体实现由编译器在编译阶段决定。</p>
<p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"Static binding\n"</span>; }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    Example obj;<br>    obj.<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 这里的 display() 调用在编译时决定，属于静态绑定</span><br>}<br></code></pre></td></tr></table></figure> 在这个示例中，<code>obj.display()</code> 是静态绑定，因为编译器在编译时决定了 <code>display</code> 方法的调用。</p>
<h4 id="动态绑定dynamic-binding">4. 动态绑定（Dynamic Binding）</h4>
<p><strong>动态绑定</strong>（或称为晚期绑定）是在运行时确定函数的调用。它通常用于虚函数（通过虚函数表 vtable）来实现多态性。</p>
<p><strong>示例</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"Base show\n"</span>; }<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>{ std::cout &lt;&lt; <span class="hljs-string">"Derived show\n"</span>; }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    Base* basePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>(); <span class="hljs-comment">// 静态类型是 Base*，动态类型是 Derived</span><br>    basePtr-&gt;<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 动态绑定，实际调用的是 Derived::show()</span><br>    <span class="hljs-keyword">delete</span> basePtr;<br>}<br></code></pre></td></tr></table></figure> 在这个示例中，<code>basePtr-&gt;show()</code> 是动态绑定，因为实际的 <code>show</code> 方法在运行时通过 <code>Derived</code> 类的虚函数表来确定。</p>
<p><strong>总结:</strong> - <strong>静态类型</strong>：编译时确定的类型（指针或引用的声明类型）。 - <strong>动态类型</strong>：运行时确定的类型（对象的实际类型）。 - <strong>静态绑定</strong>：编译时确定函数调用。 - <strong>动态绑定</strong>：运行时确定函数调用，通常通过<strong>虚函数</strong>实现多态性。</p>
<p>这些概念在 C++ 的面向对象编程中尤为重要，有助于理解如何进行函数调用、实现多态以及管理类型信息。</p>
<h3 id="虚函数和默认参数">虚函数和默认参数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span><br>{<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">	</span>{<br>		std::cout &lt;&lt; <span class="hljs-string">"E::func()\t"</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"\n"</span>;<br>	}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span> : <span class="hljs-keyword">public</span> E<br>{<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function">	</span>{<br>		std::cout &lt;&lt; <span class="hljs-string">"F::func()\t"</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"\n"</span>;<br>	}<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	F* pf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">F</span>();<br>	E* pe = pf;<br>	pf-&gt;<span class="hljs-built_in">func</span>(); <span class="hljs-comment">//F::func() 1  正常，就该如此；</span><br>	pe-&gt;<span class="hljs-built_in">func</span>(); <span class="hljs-comment">//F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span><br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>	<span class="hljs-built_in">test2</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></table></figure>
<p>这个代码的行为展示了<strong>虚函数</strong>和<strong>默认参数</strong>在 C++ 中的工作原理。关键问题出现在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pe-&gt;<span class="hljs-built_in">func</span>(); <span class="hljs-comment">// F::func() 0</span><br></code></pre></td></tr></table></figure>
<p>当调用 <code>pe-&gt;func();</code> 时，虽然函数调用的是派生类 <code>F</code> 的 <code>func()</code> 函数，但默认参数的值却使用了基类 <code>E</code> 中的默认值 <code>0</code>。这看似反常的行为其实是由 C++ 默认参数的机制造成的。</p>
<p><strong>关键点：</strong> 1. <strong>虚函数调用</strong>： - C++ 中的虚函数调用通过<strong>虚函数表（vtable）</strong> 实现。在运行时，调用的函数是根据对象的动态类型决定的。因此，<code>pe</code> 是 <code>E*</code> 类型的指针，但它指向的是 <code>F</code> 类型的对象，所以调用的函数是 <code>F::func()</code>（派生类的重写函数）。</p>
<ol start="2" type="1">
<li><strong>默认参数</strong>：
<ul>
<li>C++ 默认参数的解析是<strong>在编译时</strong>完成的，而不是在运行时。默认参数是编译器在解析函数调用时直接替换的。因此，默认参数的值取决于调用时编译器看到的函数签名。</li>
<li>在 <code>pe-&gt;func()</code> 这一行代码中，虽然调用的是 <code>F::func()</code>，但编译器在解析 <code>pe</code> 时，看到的是 <code>E*</code> 类型指针，因此它使用了基类 <code>E</code> 中的默认参数 <code>0</code>。</li>
</ul></li>
</ol>
<p><strong>为什么发生这种情况？</strong></p>
<ul>
<li>对于 <code>pf-&gt;func();</code>，编译器知道 <code>pf</code> 是 <code>F*</code> 类型的指针，所以使用 <code>F::func()</code> 的默认参数 <code>1</code>。</li>
<li>对于 <code>pe-&gt;func();</code>，编译器认为 <code>pe</code> 是 <code>E*</code> 类型的指针，因此它使用了 <code>E::func()</code> 的默认参数 <code>0</code>，尽管最终在运行时调用的是 <code>F::func()</code>。</li>
</ul>
<p><strong>解决方案:</strong></p>
<p>要避免这种令人困惑的行为，有几种方式可以选择：</p>
<ol type="1">
<li><strong>避免在虚函数中使用默认参数</strong>：
<ul>
<li>默认参数在虚函数中容易引发混淆，因为参数是在编译时绑定，而虚函数是在运行时决定调用的。最好在虚函数的参数中避免默认值，显式传递参数。</li>
</ul></li>
<li><strong>将默认参数设置为一致</strong>：
<ul>
<li>如果一定要使用默认参数，确保在基类和派生类中都使用相同的默认值。</li>
</ul></li>
</ol>
<p><strong>修改代码避免问题的示例:</strong></p>
<p>将基类和派生类中的默认参数值保持一致可以避免混淆：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span><br>{<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>)</span> <span class="hljs-comment">// 修改默认值为 1</span></span><br><span class="hljs-function">	</span>{<br>		std::cout &lt;&lt; <span class="hljs-string">"E::func()\t"</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"\n"</span>;<br>	}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span> : <span class="hljs-keyword">public</span> E<br>{<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>)</span> <span class="hljs-comment">// 保持默认值一致</span></span><br><span class="hljs-function">	</span>{<br>		std::cout &lt;&lt; <span class="hljs-string">"F::func()\t"</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"\n"</span>;<br>	}<br>};<br></code></pre></td></tr></table></figure>
<p>这样，调用 <code>pe-&gt;func();</code> 时，默认参数始终是 <code>1</code>，结果一致。</p>
<p><strong>总结:</strong></p>
<ul>
<li>虚函数的决策是<strong>运行时</strong>基于对象的动态类型进行的。</li>
<li>默认参数的决策是<strong>编译时</strong>基于指针或引用的静态类型进行的。</li>
<li>在虚函数中使用默认参数容易引发不一致的行为，因此应尽量避免。</li>
</ul>

      </div>
    </div>
    
      <script src='https://cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.min.js'></script>
      <script>
        if (window.mermaid) {
          mermaid.initialize({"startOnload":true});
        }
      </script>
    
  </article>
  <div class="post__foot">
    
    <div class="post-nav">
  
    <a class="post-nav-item-left" href="/2024/03/05/Rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AF%AF%E8%A7%A3/">
      <div class="text-align">
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
        <span class="text-small">上一篇</span>
      </div>
      <div>Rust生命周期常见误区</div>
    </a>
  
  <div class="vhr"></div>
  
    <a class="post-nav-item-right" href="/2024/02/10/Caladan:Mitigating_Interference_at_Microsecond_Timescales%E9%98%85%E8%AF%BB/">
      <div class="text-align">
        <span class="text-small">下一篇</span>
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             transform="scale(-1,-1)"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596"/>
        </svg>
      </div>
      Caladan: Mitigating Interference at Microsecond Timescales 阅读
    </a>
  
</div>

    
      <div class="related-post">
  <div class="related__head">
  <a href="/tags/C/" class="post-tag">#C</a><a href="/tags/C/" class="post-tag">#C++</a>

</div>
  <div class="realated__body">
    
      <div class="null"><div class="null-item"><div class="null-title"><a href="/2024/01/05/Duff's_device/" title="Duff's device" rel="bookmark">Duff's device</a></div></div><div class="null-item"><div class="null-title"><a href="/2023/08/31/leetcode26.删除有序数组中的重复项/" title="leetcode 26. 删除有序数组中的重复项" rel="bookmark">leetcode 26. 删除有序数组中的重复项</a></div></div><div class="null-item"><div class="null-title"><a href="/2023/12/31/leetcode4.寻找两个正序数组的中位数/" title="leetcode 4. 寻找两个正序数组的中位数" rel="bookmark">leetcode 4. 寻找两个正序数组的中位数</a></div></div><div class="null-item"><div class="null-title"><a href="/2023/11/07/@蓝色老师的LLVM系列文章汇总/" title="@蓝色老师的LLVM系列文章汇总" rel="bookmark">@蓝色老师的LLVM系列文章汇总</a></div></div><div class="null-item"><div class="null-title"><a href="/2024/01/03/AddressSanitizer/" title="AddressSanitizer" rel="bookmark">AddressSanitizer</a></div></div></div>
    
  </div>
</div>

    
    
    
      <script src="https://utteranc.es/client.js"
    repo="jtzhpf/jtzhpf.github.io"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>
    
  </div>

    </div>
    <div class="foot">
      <div class="foot-inner">
        <div class="foot__head">
          
            <div class="foot-line">
              
                <div class="matts">海</div>
              
                <div class="matts">内</div>
              
                <div class="matts">存</div>
              
                <div class="matts">知</div>
              
                <div class="matts">己</div>
              
            </div>
          
            <div class="foot-line">
              
                <div class="matts">天</div>
              
                <div class="matts">涯</div>
              
                <div class="matts">若</div>
              
                <div class="matts">比</div>
              
                <div class="matts">邻</div>
              
            </div>
          
        </div>
        <div class="foot__body">
          
            <div class="foot-item">
              <div class="foot-item__head">朋友</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://dzc2000.github.io">诚</a>
                  </div>
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/icon/icon-link.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://nuistgy.github.io/">宇</a>
                  </div>
                
                <div class="text">
                  <img alt="link" height="20px" width="20px" src="/images/icon/icon-link+.svg"/>
                  <a class="foot-link"
                     href="mailto:jtzhpf@126.com?subject=%E7%94%B3%E8%AF%B7%20ZPF.SITE%20%E7%9A%84%E5%8F%8B%E9%93%BE%E4%BD%8D%E7%BD%AE">
                  申请友链</a>
                </div>
              </div>
            </div>
          
          
            <div class="foot-item">
              <div class="foot-item__head">账号</div>
              <div class="foot-item__body">
                
                  <div class="text">
                    <img alt="link" height="20px" width="20px" src="/images/logo-github.svg"/>
                    <a class="foot-link" target="_blank" rel="noopener" href="https://github.com/jtzhpf">github</a>
                  </div>
                
              </div>
            </div>
          
          <div class="foot-item">
            <div class="foot-item__head">联系</div>
            <div class="foot-item__body">
              <div class="text">
                <img alt="link" height="20px" width="20px" src="/images/icon/icon-email.svg"/>
                <a class="foot-link" href="mailto:jtzhpf@126.com">jtzhpf@126.com</a>
              </div>
            </div>
          </div>
          <div class="foot-item">
            <div class="foot-item__head">访客</div>
            <div class="foot-item__body">
              <div class="text">
                <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
                <span class="post-meta-divider"> &nbsp;|&nbsp; </span>
                <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>
              </div>
            </div>
          </div>
        </div>
        <div class="copyright">
          <a href="https://zpf.pages.dev">ZPF.SITE</a> &nbsp;|&nbsp;由&nbsp;<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>&nbsp;及&nbsp;
          <svg width="20" height="20" viewBox="0 0 725 725">
            <path fill-rule="evenodd" fill="rgb(221, 221, 221)" d="M145.870,236.632 L396.955,103.578 L431.292,419.44 L156.600,522.53 L145.870,236.632 Z"/>
            <path fill-rule="evenodd" fill="rgb(159, 159, 159)" d="M396.955,103.578 L564.345,234.486 L611.558,513.469 L431.292,419.44 L396.955,103.578 Z"/>
            <path fill-rule="evenodd" fill="rgb(0, 0, 0)" d="M431.292,419.44 L611.558,513.469 L358.327,595.18 L156.600,522.53 L431.292,419.44 Z"/>
          </svg>
          <a target="_blank" rel="noopener" href="https://github.com/jtzhpf/hexo-theme-tranquility">致远</a>&nbsp;驱动
        </div>
      </div>
    </div>
    
      <script src="https://unpkg.com/js-polyfills@0.1.43/es6.js"></script>
      <script id="MathJax-script"
              async
              src="https://www.unpkg.com/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>
    
    
  

  </body>
</html>